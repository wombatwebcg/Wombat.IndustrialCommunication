# 上下文
文件名：Modbus地址兼容性改造任务.md
创建于：2024-12-19
创建者：AI助手
关联协议：RIPER-5 + Multidimensional + Agent Protocol 

# 任务描述
改造Modbus的地址兼容性，支持两种地址格式：
1. 原有格式：`1;3;0` (站号;功能码;寄存器地址)
2. 新格式：`1;400001` (站号;寄存器地址) - 功能码根据写入值类型自动判断

新格式要求：
- 支持400001和40001这样的地址格式（支持更大范围，不止9999）
- 通过判断地址开头字符是否为"4"来识别可保存寄存器
- 写入int类型使用6号功能码，写入int32类型使用16号功能码
- 保持向后兼容性

# 项目概述
这是一个工业通信库中的Modbus模块地址解析器改造项目。当前系统使用`ModbusAddressParser`类处理地址解析，需要扩展以支持新的地址格式，同时保持对现有格式的兼容性。

---
*以下部分由 AI 在协议执行过程中维护*
---

# 分析 (由 RESEARCH 模式填充)

## 当前系统分析

### 核心文件结构
- `ModbusAddressParser.cs` - 当前地址解析器
- `ModbusHeader.cs` - 地址信息模型  
- `ModbusInput.cs` - 输入模型，包含DataTypeEnums
- `ModbusOutput.cs` - 输出模型
- `IModbusClient.cs` - Modbus客户端接口

### 当前地址格式
- 格式：`站号;功能码;寄存器地址`
- 示例：`1;3;0`
- 解析逻辑：按分号分割，分别解析站号、功能码、地址

### 地址范围分析
从代码中发现：
- 当前系统支持ushort类型的地址（0-65535）
- 在`ModbusTcpRequest.cs`中看到地址格式化逻辑：
  - 保持寄存器：`(registerAddress + 40001).ToString()`
  - 输入寄存器：`(registerAddress + 30001).ToString()`
  - 线圈：`(registerAddress + 1).ToString("00000")`
  - 离散输入：`(registerAddress + 10001).ToString()`

### 数据类型系统
- 使用`DataTypeEnums`枚举（来自Wombat.Extensions.DataTypeExtensions）
- 支持：Bool, Byte, Int16, UInt16, Int32, UInt32, Int64, UInt64, Float, Double等

### 功能码映射
- 01: 读线圈
- 02: 读离散输入  
- 03: 读保持寄存器
- 04: 读输入寄存器
- 05: 写单个线圈
- 06: 写单个寄存器
- 15: 写多个线圈
- 16: 写多个寄存器

### 约束条件
1. 必须保持向后兼容性
2. 新格式需要根据数据类型自动判断功能码
3. 地址格式需要支持400001和40001两种形式（支持更大范围）
4. 通过地址开头字符"4"识别可保存寄存器
5. 需要与现有的批量读写系统集成

# 提议的解决方案 (由 INNOVATE 模式填充)

## 推荐方案：增强解析器 + 智能地址识别

### 核心思路
扩展现有的`ModbusAddressParser`类，添加智能地址格式识别和功能码自动判断功能。

### 地址识别策略
1. **格式检测**：
   - 3个分号分隔符 → 原有格式 `站号;功能码;地址`
   - 2个分号分隔符 → 新格式 `站号;地址`

2. **寄存器类型识别**：
   - 地址以"4"开头 → 可保存寄存器（保持寄存器）
   - 地址以"3"开头 → 输入寄存器
   - 地址以"1"开头 → 线圈
   - 地址以"2"开头 → 离散输入

3. **功能码自动判断**：
   - Bool类型 → 05(写线圈) / 01(读线圈)
   - Int16/UInt16 → 06(写单个寄存器) / 03(读保持寄存器)  
   - Int32/UInt32/Float → 16(写多个寄存器) / 03(读保持寄存器)
   - Int64/UInt64/Double → 16(写多个寄存器) / 03(读保持寄存器)

4. **地址标准化**：
   - 400001 → 40001 (去掉前导零，但保持大地址支持)
   - 支持更大的地址范围（不止9999）

### 优势
- 最小化代码变更
- 保持现有接口不变
- 支持更大地址范围
- 智能功能码判断
- 完全向后兼容

# 实施计划 (由 PLAN 模式生成)

## 详细实施步骤

### 步骤1：扩展ModbusAddressParser类
- 文件：`Wombat.IndustrialCommunication/Modbus/Base/ModbusAddressParser.cs`
- 添加新的解析方法支持两种格式
- 实现地址类型自动识别
- 添加功能码自动判断逻辑

### 步骤2：增强ModbusHeader模型
- 文件：`Wombat.IndustrialCommunication/Modbus/Models/ModBusInput.cs`
- 添加地址格式标识属性
- 添加自动功能码判断属性

### 步骤3：更新批量处理逻辑
- 文件：`Wombat.IndustrialCommunication/Modbus/ModbusBatchHelper.cs`
- 集成新的地址解析逻辑
- 确保批量读写支持新格式

### 步骤4：添加单元测试
- 创建测试用例验证新格式
- 验证向后兼容性
- 测试大地址范围支持

### 步骤5：更新文档
- 更新API文档
- 添加新格式使用示例

实施检查清单：
1. 修改ModbusAddressParser.cs，添加新格式解析方法
2. 实现地址类型自动识别逻辑（4开头=可保存寄存器）
3. 实现功能码自动判断逻辑（根据DataTypeEnums）
4. 扩展ModbusHeader模型，添加格式标识属性
5. 更新ModbusBatchHelper.cs，集成新解析逻辑
6. 添加单元测试验证新功能
7. 验证向后兼容性
8. 更新相关文档

# 当前执行步骤 (由 EXECUTE 模式在开始执行某步骤时更新)
> 正在执行: "[步骤编号和名称]"

# 任务进度 (由 EXECUTE 模式在每步完成后追加)
*   [日期时间]
    *   步骤：[检查清单项目编号和描述]
    *   修改：[文件和代码更改列表，包括已报告的微小偏差修正]
    *   更改摘要：[简述本次更改]
    *   原因：[执行计划步骤 [X]]
    *   阻碍：[遇到的任何问题，或无]
    *   用户确认状态：[成功 / 成功但有小问题 / 失败]
*   [日期时间]
    *   步骤：...

# 最终审查 (由 REVIEW 模式填充)
[实施与最终计划的符合性评估总结，是否发现未报告偏差] 