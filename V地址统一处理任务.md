# 上下文
文件名：V地址统一处理任务.md
创建于：2024-12-19
创建者：AI
关联协议：RIPER-5 + Multidimensional + Agent Protocol 

# 任务描述
统一V地址的写法，支持以下格式：
- V1.0 表示位的地址
- V1 表示byte的地址  
- VW1 表示字的地址
- VD1 表示双字的地址

# 项目概述
这是一个西门子S7 PLC通信库，当前V地址的处理比较简单，只是将DbBlock设置为1，然后调用GetBeingAddress方法处理剩余部分。需要增强V地址的解析能力，支持不同的数据类型标识符。

---
*以下部分由 AI 在协议执行过程中维护*
---

# 分析 (由 RESEARCH 模式填充)

## 当前V地址处理逻辑分析

### 现有代码结构
1. **S7CommonMethods.cs** 中的 `ConvertArg` 方法（第69-116行）
   - 当前V地址处理：`else if (firstChar == 'V')`
   - 简单地将 `DbBlock` 设置为 1
   - 调用 `GetBeingAddress(address.Substring(1), offest)` 处理剩余部分

2. **SiemensAddress 类结构**
   - `Address`: 原地址字符串
   - `DataType`: 数据类型（DataTypeEnums）
   - `TypeCode`: 区域类型代码（V区为0x84）
   - `DbBlock`: DB块编号（V区固定为1）
   - `BeginAddress`: 开始地址
   - `ReadWriteLength`: 读取或写入长度
   - `IsBit`: 是否位操作

3. **DataTypeEnums 支持的数据类型**
   - Bool, Byte, Int16, UInt16, Int32, UInt32, Int64, UInt64, Float, Double
   - 在 `DataTypeInfo` 字典中定义了每种类型的长度和是否为位操作

4. **GetBeingAddress 方法**
   - 处理地址偏移计算
   - 支持带小数点的位地址格式

### 当前问题
1. V地址解析过于简单，没有区分不同的数据类型标识符
2. 无法自动识别 V1.0（位）、V1（字节）、VW1（字）、VD1（双字）等格式
3. 缺少对V区地址格式的验证和错误处理

### 相关依赖
1. `SiemensAddress` 类用于存储解析后的地址信息
2. `DataTypeEnums` 枚举定义支持的数据类型
3. `DataTypeInfo` 字典提供数据类型长度信息
4. `GetBeingAddress` 方法处理地址偏移计算

# 提议的解决方案 (由 INNOVATE 模式填充)

## 解决方案探索

### 方案1：扩展现有V地址处理逻辑
**优点：**
- 最小化代码变更，保持现有架构
- 向后兼容现有的V地址格式
- 实现相对简单

**缺点：**
- 需要在现有方法中添加复杂的条件判断
- 可能导致方法过长，可读性下降
- 扩展性有限

### 方案2：创建专门的V地址解析方法
**优点：**
- 代码结构清晰，职责分离
- 易于维护和扩展
- 可以独立测试V地址解析逻辑

**缺点：**
- 需要重构现有代码
- 可能影响其他地址类型的处理

### 方案3：使用正则表达式解析V地址
**优点：**
- 解析逻辑清晰，易于理解
- 支持复杂的地址格式匹配
- 易于扩展新的地址格式

**缺点：**
- 正则表达式可能影响性能
- 调试相对困难
- 需要仔细处理边界情况

### 方案4：基于状态机的地址解析
**优点：**
- 解析逻辑非常清晰
- 易于处理复杂的地址格式
- 高度可扩展

**缺点：**
- 实现复杂度较高
- 可能过度设计
- 学习成本较高

## 推荐方案

经过权衡，推荐**方案2：创建专门的V地址解析方法**，结合**方案3的正则表达式**来解析不同的V地址格式。

### 具体实现思路

1. **创建 `ParseVAddress` 方法**：专门处理V地址解析
2. **定义V地址格式模式**：
   - `V\d+\.\d+` - 位地址（如 V1.0）
   - `V\d+` - 字节地址（如 V1）
   - `VW\d+` - 字地址（如 VW1）
   - `VD\d+` - 双字地址（如 VD1）
3. **自动推断数据类型**：根据地址格式自动设置相应的数据类型
4. **错误处理**：提供清晰的错误信息

### 优势
1. **清晰的责任分离**：将V地址解析逻辑独立出来，便于维护
2. **灵活的格式支持**：使用正则表达式可以轻松支持各种V地址格式
3. **良好的扩展性**：未来可以轻松添加新的V地址格式
4. **向后兼容**：保持对现有V地址格式的支持

# 实施计划 (由 PLAN 模式生成)

## 详细实施计划

### 文件修改计划

**目标文件：** `Wombat.IndustrialCommunication/PLC/S7/S7CommonMethods.cs`
**修改范围：** 第69-116行的 `ConvertArg` 方法中的V地址处理部分

### 具体修改内容

1. **替换现有的V地址处理逻辑**
   - 当前代码：`else if (firstChar == 'V')` 部分（第95-98行）
   - 新的逻辑需要支持：
     - `V1.0` - 位地址（DataTypeEnums.Bool）
     - `V1` - 字节地址（DataTypeEnums.Byte）
     - `VW1` - 字地址（DataTypeEnums.Int16）
     - `VD1` - 双字地址（DataTypeEnums.Int32）

2. **V地址格式解析逻辑**
   - 检查地址长度和字符模式
   - 根据地址格式推断数据类型
   - 设置相应的 `DataType`、`ReadWriteLength` 和 `IsBit` 属性

3. **保持现有架构**
   - 不添加新的私有方法
   - 不引入正则表达式
   - 保持方法签名不变

### 修改策略

**V地址解析逻辑：**
1. 检查是否为 `VW` 开头（字地址）
2. 检查是否为 `VD` 开头（双字地址）
3. 检查是否包含小数点（位地址）
4. 默认为字节地址

**数据类型映射：**
- `V1.0` → `DataTypeEnums.Bool`, `IsBit = true`, `ReadWriteLength = 1`
- `V1` → `DataTypeEnums.Byte`, `IsBit = false`, `ReadWriteLength = 1`
- `VW1` → `DataTypeEnums.Int16`, `IsBit = false`, `ReadWriteLength = 2`
- `VD1` → `DataTypeEnums.Int32`, `IsBit = false`, `ReadWriteLength = 4`

### 错误处理

- 保持现有的参数验证逻辑
- 添加V地址格式验证
- 提供清晰的错误信息

实施检查清单：
1. 在 `ConvertArg` 方法中定位V地址处理部分（第95-98行）
2. 替换现有的V地址处理逻辑，添加格式识别
3. 根据地址格式设置相应的数据类型和长度
4. 添加V地址格式验证和错误处理
5. 确保向后兼容现有的V地址格式
6. 测试修改后的方法功能

# 当前执行步骤 (由 EXECUTE 模式在开始执行某步骤时更新)
> 正在执行: "步骤1-3：修改V地址处理逻辑"

# 任务进度 (由 EXECUTE 模式在每步完成后追加)
*   2024-12-19
    *   步骤：步骤1-3：修改V地址处理逻辑
    *   修改：Wombat.IndustrialCommunication/PLC/S7/S7CommonMethods.cs 第95-116行
    *   更改摘要：替换了原有的简单V地址处理逻辑，新增了对V1.0（位）、V1（字节）、VW1（字）、VD1（双字）格式的支持，自动设置相应的数据类型、长度和位操作标志
    *   原因：执行计划步骤 1-3
    *   阻碍：无
    *   状态：待确认

# 最终审查 (由 REVIEW 模式填充) 